
# Требования
## Функциональные требования
* Возможность выставления разных квот для разных клиентов
* Возможность пересчета коэффициентов нагрузки при падении одной из нод лимитера
## Нефункциональные требования
* Высокая доступность (99.9%)
* Масштабируемость
* Время ответа 1 мс 

Предполагаем:
* число уникальных пользователей - 1 млн
* ежесекундное число активных пользователей - 50 тысяч
* среднее число отправляемых сообщений клиенту- 2 сообщения в секунду
* нагрузка на лимитер 100 тысяч запросов в секунду. 

Исходя из требования в 1 мс на время отклика, необходимо не менее 100 вычислительных ядер, или не менее 7 физических серверов с 16-ядерными ЦП.

Для заданных требований был выбран протокол HTTP и модель синхронного взаимодействия между сервисом и лимитером, так как сессии короткие и многочисленные, а время ответа невелико. 

## Модель данных

### БД
* Id клиента - 4 байта - (int)
* Квота на число запросов - 4 байта
* Размер временного окна в мс - 4 байта

=> На 1.000.000 пользователей 11.44 Мбайт.
Для таких объёмов данных достаточно PostgreSQL.

### ОЗУ
* Id клиента - 4 байта
* Ссылка на лимитер - 4 байта
* Размер окна в мс - 8 байт
* Максимальное число запросов в окне - 4 байта

=> На 1.000.000 клиентов ~19.07 Мбайт 

Каждое окно в лимитере содержит:
* Id окна - 8 байт
* Число запросов в данном окне - 16 байт - (AtomicInteger)

=> Общий размер 24 байта.

Если каждое окно имеет длину порядка минуты и проводим очистку раз в час, то постоянно будет храниться 60 окон. 

На пользователя - 1440 байт => На 1.000.000 пользователей ~1.34 Гбайт данных.
